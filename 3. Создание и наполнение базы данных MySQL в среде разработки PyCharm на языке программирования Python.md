# 3. Создание и наполнение базы данных MySQL в среде разработки PyCharm на языке программирования Python.

## 3.1 Создание базы данных MySQL.

Данные базы находятся в CSV файлах. Для того, чтобы импортировать их в базу данных MySQL можно воспользоваться языком 
программирования Python.
Для начала загрузки необходимо создать базу данных, далее БД.
Воспользуемся популярной библиотекой PyMySQL, которая подходит для работы с большими данными. Данная библиотка обеспечивает доступ к системе управления базами данных MySQL из приложений написанных на языке программирования Python. 
Следующий код создает подключение к серверу MySQL с помощью метода connect(), отправляет запрос на создание новой базы данных с 
помощью метода execute(), а затем закрывает подключение к серверу с помощью метода close(). Запрос CREATE DATABASE IF NOT EXISTS сохраняется в виде строки в переменной create_database_query, а затем передается на выполнение в cursor.execute()
Чтобы начать работать с MySQL, необходимо создать объект cursor. Это объект, который содержит в себе различные методы для проведения SQL команд. Можно просто положить его значение в переменную cursor = connection.cursor(), можно воспользоваться контекстным менеджером with.
Существует несколько типов курсоров, доступных через Pymysql. Здесь использован DictCursor, для того, чтобы результат запроса 
был в виде словаря, который облегачет доступ к данным. Тип курсора можно выбрать при создании подключения к базе данных с помощью метода connect() и передать его в качестве аргумента cursorclass.
Для того чтобы выполнить запрос на создание таблицы, вызываем у cursor метод execute, и передаем в него наш запрос. Выведем в print сообщение об успешном исполнении.
Код находится оболочке try/except. В блоке try производится подключение к БД, а блок except выводит возможные ошибки в терминал. После подключения и работы с БД, соединение необходимо закрыть. Используем оболочку try/finally. Внутри блока try - запросы к БД, 
 внутри блока finally будет закрываться само соединение. 
 
```python
import pymysql

host = '127.0.0.1'
user = 'root'
password = '********'

try:
    connection = pymysql.connect(
        host=host,
        port=3306,
        user=user,
        password=password,
        cursorclass=pymysql.cursors.DictCursor
    )
    print("successfully connected...")
    print("#" * 20)

    try:
        # create table
        with connection.cursor() as cursor:
            create_database_query = '''CREATE DATABASE IF NOT EXISTS diploma;'''
            cursor.execute(create_database_query)
            print("DataBase is created successfully")
    finally:
        connection.close()

except Exception as ex:
    print("Connection refused...")
    print(ex)
```
Используем тот же самый скрипт для создания таблицы в БД. Стандартный SQL запрос на создание таблицы с указанием названий необходимых полей и типов данных сохраняется в виде строки в переменной create_table_query, а затем передается на выполнение в cursor.execute()

```python
import pymysql

host = '127.0.0.1'
user = 'root'
password = '********'
db_name = 'diploma'

try:
    connection = pymysql.connect(
        host=host,
        port=3306,
        user=user,
        password=password,
        database=db_name,
        cursorclass=pymysql.cursors.DictCursor
    )
    print("successfully connected...")
    print("#" * 20)

    try:
        # create table
        with connection.cursor() as cursor:
            create_table_query = '''CREATE TABLE IF NOT EXISTS ` DIPLOMA `.` stat_citizens ` (
  ` region_code ` VARCHAR(25) NULL COMMENT 'Код региона',
  ` region_name ` VARCHAR(45) NULL COMMENT 'Наименование региона (на русском)',
  ` cvs_count ` VARCHAR(15) NULL COMMENT 'Количество резюме',
  ` medium_salary ` VARCHAR(15) NULL COMMENT 'Средняя заработная плата',
  ` region_code_mistake ` VARCHAR(5) NULL COMMENT 'Ошибки в датах атрибута region_code (длина не 13 цифр)');'''
            cursor.execute(create_table_query)
            print("Table created successfully")
    finally:
        connection.close()

except Exception as ex:
    print("Connection refused...")
    print(ex)

```

## 3.2 Основной скрипт построчной загрузки данных в MySQL.

Для дальнейшей более удобной работы с данными их можно загрузить в БД. В нашем случае это MySQL. Данные достаточно объемные и в них есть символы и emoji, которые могут мешать полноценной заргузке. Нам нужны будут два файла: один - это файл источник, из которого будут считываться строки и пустой файл для ошибок, строк, которые по какой-то причине не могли быть загружены в БД MySQL.
Этот код использует библиотеку mysql.connector для подключения к MySQL и работой с двумя CSV-файлами.
Далее код выполняет цикл по одному файлу и загружает данные из каждой строки в указанную таблицу. Если встречается ошибка, она записывается во второй файл, файл ошибок для дальнейшего анализа.

```python
import MySQLdb as mysql
import emoji
from MySQLdb.constants.FIELD_TYPE import NULL

host = '127.0.0.1'
user = 'root'
password = '********'
db_name = 'diploma'

from mysql.connector import IntegrityError, Error

file = "file_path_one.csv"
file_e = "file_path_two.csv"

try:
    conn = mysql.connect(host=host, database=db_name, user=user, password=password)
    if conn.open:
        cursor = conn.cursor()
        cursor.execute("select database();")
        record = cursor.fetchone()
        print("You're connected to database: ", record)

        # loop through the data frame
        src_file = open(file, mode="r", encoding="utf-8")
        err_file = open(file_e, mode="w", encoding="utf-8")
        run = True
        head = src_file.readline()
        err_file.writelines(head)
        while run:
            row1 = src_file.readline()
            if row1 == '':
                run = False
                break
            if not row1[:5] == '*****':
                row2 = row1.replace('\n', '')
                row2 = emoji.demojize(row2)
                row2 = row2.split(';')
                for i in row2:
                    if i == '':
                        i = NULL 
                # print(i)
                s = "('" + "','".join(row2) + "');"
                sql = '''INSERT INTO `db_name`.`table_name` VALUES ''' + s
                try:
                    cursor.execute(sql)
                    conn.commit()
                except:
                    err_file.writelines(row1)
        try:
            conn.commit()
        finally:
            print('final')
        src_file.close()
        err_file.close()
except Error as e:
    print("Error while connecting to MySQL", e)
    conn.close()

```
MySQLdb - библиотека для подключения к БД MySQL, позволяющая выполнять MySQL запросы с использованием Python. 
Модуль FIELD_TYPE содержит константы, которые используются в запросах MySQL: NULL, INT, VARCHAR, и т.д. В данном коде загружена константа NULL для дальнейшей работы с типами данных в БД, поля должны быть не пустыми (''), а не содержать значения поля, т.е. быть значением NULL.
import emoji - загружает библиотеку для взаимодействия с емодзи или смайлами в коде python. В данном случает при помощи этого модуля можно удалить картинки, которые никак не влияют на дальнейший анализ БД, но препятствуют загрузке данных. Функция demojize из библиотеки emoji принимает в качестве аргумента строку и сохраняет ее в переменную уже в измененном виде: эмодзи в данной строке представлены в текстовом формате.
Так же для взаимодейтвия со специфическими ошибками, встречающимися при работе с базами данных, из модуля mysql.connector импортированы два класса объектов MySQLdb: IntegrityError и Error. 
Класс IntegrityError сообщает об ошибках, касающихся ограничений, наложенных на данные в БД: NOT NULL, UNIQUE, FOREIGN KEY и другие. Например, при попытке загрузить в базу дубликата строки, при наличии поля UNIQUE, будет выводиться ошибка IntegrityError с указанием, что попытка данной загрузки не удалась из-за имеющихся ограничений. 
Данный код подключения к БД и выполнения запроса на загрузку данных обернут в оболочку try/except. При наличии проблем с подключением к БД будет выполнен блок Ecxept, который выведет на консоль ошибку Error. Это класс ошибок подключения к серверу. Нужно проверить данные подключения, м.б.перегрузить сам сервер и т.д.
Метод cursor() возвращает объект типа Cursor, который используется для выполнения запросов к базе данных. Таким образом он запрашивает название текущей базы данных через запрос "select database();"
Метод fetchone() возвращает первую строку (элемент) из набора результатов запроса и сохраняет в переменную record. 
Затем на консоль выводится сообщение, что подключение успешно и содержимое переменной record, т.е. название текущей базы подключения. 
Код учитывает, что файл-источник (src_file) открывается в режиме чтения данных (mode='r'), а файл для сохранения ошибочных строк (err_file) - для записи (mode='w'). Если файла для переменной err_file не существует, то будет создан пустой файл по заданному выше пути.
Далее начинается цикл по датафрейму, который продолжается пока состояние переменной run (ее еще называют "флагом") будет True.
Внутри цикла, код считывает по одной строке из файла-источника при помощи метода .readline() и сохраняет ее в переменную.
Как только переменная становится пустой строкой, цикл заканчивается(run=False).
Первая строка CSV файла - это заголовки столбцов, поэтому при создании файла для ошибок эта строка первым делом и записывается в переменную head при помощи метода .writelines(head). Когда есть заголовки столбцов, осуществлять импорт csv файла в какой-либо из инструментов для анализа, например в MS Excel будет проще. 
Первые 5 символов строки не должны совпадать с первыми 5 символами строки-заголовка. Если совпадают, считывается по циклу следующая строка, таким образом пропуская строку заголовков. В результате нужная строка сохраняется в переменную, подстрока '\n' (обозначение конца строки, непечатный символ) заменяется на пустую подстроку. 
Эмодзи в строке заменяются на их текстовую версию. 
Далее строка делится по разделителю csv файла (в данном случает это точка с запятой) на список значений методом строки .split(';'). 
Далее в цикле пустые строки списка заменяются на значение NULL, константу из SQL. 
Затем создается переменная, в которую сохраняется будущий SQL запрос. Сложность состоит в том, что база в CSV файлах содержала много кавычек как одинарных так и двойных. После первого же анализа ошибок из файла err_file стало понятно, что строка SQL запроса должна содержать поля в одинарных кавычках, т.к. двойных кавычек в базе значительно больше. Это снизит количество ошибочных строк. 
Метод .join(), преобразует список элементов в строку, разделенную запятыми, а конкатенация добавит в начале и в конце строки скобки и недостающие одинарные кавычки.
Таким образом при помощи опять же конкатенации и переменной s формируется полноценный SQL запрос в базу данных на импорт строки в указанную таблицу БД.
Далее при помощи try/except блока мы либо сохраняем строку в БД (метод conn.commit() сохраняет изменения), либо в блоке except эта строка записывается в файл ошибок "err_file" при помощи метода .writelines().
После завершения заново вызывается метод conn.commit() для сохранения всех имеющихся изменений, файлы закрываются и выводится сообщение об окончании работы кода.

## 3.3 Вывод на консоль ошибки, препятствующей загрузке файла.

Данный код является почти точной копией кода из подпункта 3.2 данной главы. Отличие состоит только в том, что в блоке try/except, на консоль выводится сам SQL запрос, а при неблагополучном выполнении данного SQL запроса, и строковое сообщение об ошибке. Используется данный код для анализа файла ошибок. Но с этой целью использовать его можно только один раз, т.к. после исправления, производить основную построчную загрузка исправленного файла ошибок в базу необходимо уже кодом из подпункта 3.2.

```python
import MySQLdb as mysql

host = '127.0.0.1'
user = 'root'
password = '********'
db_name = 'diploma'

from mysql.connector import IntegrityError, Error

file = "file_one_path.csv"
file_e = "file_two_path.csv"

try:
    conn = mysql.connect(host=host, database=db_name, user=user, password=password)
    if conn.open:
        cursor = conn.cursor()
        cursor.execute("select database();")
        record = cursor.fetchone()
        print("You're connected to database: ", record)

        # loop through the data frame
        src_file = open(file, mode="r", encoding="utf-8")
        err_file = open(file_e, mode="w", encoding="utf-8")
        run = True
        head = src_file.readline()
        while run:
            row1 = src_file.readline()
            if row1 == '':
                run = False
                break;
            if not row1[:5] == '*****':
                row2 = row1.replace('\n', '')
                row2 = row2.split(';')
                for i in row2:
                    if i == '':
                        i = NULL
                s = "('" + "','".join(row2) + "');"
                sql = '''INSERT INTO `db_name`.`table_name` VALUES ''' + s
                try:
                    print(sql)
                    cursor.execute(sql)
                    conn.commit()
                except Error as e1:
                    print(e1.msg)
                    err_file.writelines(row1)
        try:
            conn.commit()
        finally:
            print('final')

        src_file.close()
        err_file.close()
except Error as e:
    print("Error while connecting to MySQL", e)
    conn.close()
```
## 3.4 Анализ ошибок, препятствующих загрузке данных CSV файла в БД MySQL.

Ошибки, препятствующие корректной загрузке данной БД из CSV файлов в MySQL:
-	Наличие точек с запятыми, одинарных кавычек, введенных пользователями и сохранившихся в имеющихся CSV файлах;
-	Большое количество эмодзи разных видов создающих ошибки связанные с распознаванием кодировки (эмодзи мы заменяем на текстовую версию при первичной загрузке файла в подпункте 3.2);
-	Наличие символов обратной косой черты «обратный слэш» непосредственно в конце строки перед разделителем точкой с запятой; 
-	Кодировка, отличная от UTF-8 (правильная кодировка указывается при сохранении файла, при импорте в любой из необходимых инструментов и при чтении CSV);
-	Наличие непечатного символа '\n' в текстовых сообщениях в ячейках столбцов.

#### 3.4.1 Наличие одинарных кавычек.

Если файл все еще слишком большой, чтобы импортировать его в какой-то из редакторов, можно использовать следующий код для того, чтобы, например, заменить одинарные кавычки на обратные. Это исправит некоторый процент строк для последующей безошибочной загрузки в MySQL.

```python
import csv

n = 0 
src_file = open(source_file_path, mode="r", encoding="utf-8")
file_ch = open(file_path_for_change, mode='a', encoding='utf-8')
run = True
head = src_file.readline()
file_ch.writelines(head)
while run:
    row1 = src_file.readline()
    if row1 == '':
        run = False
        break 
    if not row1[:5] == '*****':
        row2 = row1.replace('\n', '')
        row2 = row2.replace("'", "`") 
        row2 = row2.split(';')
        s = ';'.join(row2) + '\n'
        file_ch.writelines(s)
        n += 1
src_file.close()
file_ch.close()
print(f'{n} строк')
print('fin')

```

### 3.4.2 Наличие точек с запятыми и '\n' в текстовых сообщениях столбцов CSV файла. 

CSV — это стандартный формат хранения данных в таблицах. Каждый столбец в файле CSV отделен друг от друга символом запятой или в нашем случае - точкой с запятой. Это позволяет программам читать и писать данные в файле.
Наличие точек с запятой могут ложно распознаваться кодом как разделители, не являясь таковыми. А наличие '\n' - распознаваться, как конец строки, так же не являясь таковым.
Воспользуемся возможностями MS Excel. 
Для того, чтобы Excel корректно прочитал CSV файл, надо его не просто открыть, а импортировать. В этом случае мы учтем и разделитель и кодировку. Во вкладке «Данные» нажать на кнопку «Из текстового/CSV-файла», далее выбрать файл, кодировку и разделитель – точку с запятой. Excel правильно распределяет данные по колонкам с заголовками (для этого в обязательном порядке мы сохраняли заголовки столбцов первой строкой в любых используемых CSV файлах). Теперь можно воспользоваться инструментом по замене всех точек с запятой на запятые, а все символы '\n' в ячейках таблицы на подстроку '' без какого либо значения внутри подстроки. Вкладка «Главная» - «Найти и выделить» - «Заменить…» 
Далее файл надо сохранить как CSV. По умолчанию Excel предлагает сохранить CSV файл с разделителем запятой. Для того, чтобы на самом деле разделителем стала точка с запятой, нужно поменять региональные настройки Windows на ноутбуке или ПК: пуск – панель управления – изменение форматов даты, времени и чисел – вкладка «форматы» - кнопка «дополнительные параметры» - разделитель элементов (точка с запятой). 
Теперь при сохранении файла из Excel, указываем, что сохранить его нужно как CSV c разделителем запятой. Несмотря на то, что разделитель указан как запятая, при правильных настройках файл сохранится с нужным нам разделителем, т.к. региональные настройки уже изменены. 
Здесь нужно учесть, что дальнейшее назначение сохраненного файла - это загрузка в БД MySQL. Excel меняет формат даты столбца согласно своим настройкам. Поэтому перед сохранением файла в CSV необходимо по очереди выделить каждый столбец с датой, зайти в «Формат ячеек» и выбрать дату в нужном нам формате: например, 2012-12-10.

### 3.4.3 Наличие символов обратной косой черты «обратный слэш» непосредственно в конце строки перед разделителем точкой с запятой.

Наличие обратного слэша перед разделителем ';' экранирует данный разделитель и код его не распознает, выводя ошибку о некорректном количестве столбцов в строке. Самый простой способ для того, чтобы убрать все сочетания '\;' из CSV файла, 
это открыть его в приложении «Блокнот» из стандартного пакета Microsoft Office и заменить '\;' на ';'. Далее просто сохранить данный файл.

## 3.5 Разделение CSV файла на CSV файлы меньшего размера согласно указанному количеству строк.

Иногда даже файл с ошибками может быть слишком большим для того, чтобы открыть его каким-либо из инструментов. Тогда большой файл можно разделить на файлы поменьше. Например, вот так:

```python
import csv

src_file = open("file_path_1.csv", mode="r", encoding="utf-8")
file_ch_1 = open("file_path_1.1.csv", mode='a', encoding='utf-8')
file_ch_2 = open("file_path_1.2.csv", mode='a', encoding='utf-8')
file_ch_3 = open("file_path_1.3.csv", mode='a', encoding='utf-8')

run = True
head = src_file.readline()
file_ch_1.writelines(head)
file_ch_2.writelines(head)
file_ch_3.writelines(head)

n = 0
while run:
    row1 = src_file.readline()
    if row1 == '':
        run = False
        break
    elif n < 21_237 and not row1[:5] == '*****':
        row2 = row1.replace('/n', '')
        row2 = row2.split(';')
        s = ';'.join(row2)
        file_ch_1.writelines(s)
        n += 1
    elif n > 21_236 and n < 42_474 and not row1[:5] == '*****':
        row2 = row1.replace('/n', '')
        row2 = row2.split(';')
        s = ';'.join(row2)
        file_ch_2.writelines(s)
        n += 1
    elif n > 42_473 and not row1[:5] == '*****':
        row2 = row1.replace('/n', '')
        row2 = row2.split(';')
        s = ';'.join(row2)
        file_ch_3.writelines(s)
        n += 1
src_file.close()
file_ch_1.close()
file_ch_2.close()
file_ch_3.close()
print('fin')
```
В данном примере из одного большого CSV файла создаются 3 файла поменьше. Количество строк указано.
Учитываем, что в каждом из файлов должны сохраниться заголовки колонок. Т.е. первая строка исходного CSV файла. И все файлы, с которыми работали, надо закрыть, иначе они могут оказаться недоступными для дальнейшего использования как файлы, уже открытые другой программой.

## 3.6 Типы данных MySQL.

MySQL позволяет изменять тип данных столбца при его создании или после этого. Однако, если в столбце есть ячейки, содержащие пустые строки (''), их надо заменить на отсутствие значения NULL или на любое другое значение, установленное в столбце по умолчанию. Например, если нужно поменять тип данных столбца на TINYINT для значений 0 или 1, а по умолчанию должен стоять 0, тогда пустые строки надо заменить на ноль.

```SQL
-- поменять пустые строки на NULL
UPDATE table
SET column_name = NULL
	WHERE column_name = '';
```

``` SQL
-- изменить тип данных столбца с указанием значения по умолчанию (0)
ALTER TABLE table_name
MODIFY column_name TINYINT DEFAULT 0;
```

MySQL Server поддерживает однобайтный тип данных YEAR, предназначенный для представления значений года в формате YYYY. Диапазон возможных значений - от 1901 до 2155. Наличие года, не входящего в данный диапазон вызовет ошибку при смене типа данных на YEAR.
Все данные в столбце birthday отмечены в столбце birthday_mistake как ошибочные или нет: 1 или 0. Соответственно значения birthday соответствующие значению birthday_mistake = 1, необходимо заменить на NULL и тип данных можно будет поменять.

``` SQL
-- убираем некорректные данные, которые не представляют интереса
UPDATE curricula_vitae SET birthday = NULL WHERE birthday_mistake = 1;
```
## 3.6.1 Изменение формата даты и регулярные выражения.

MySQL хранит даты в определенном формате. Вот для примера результат запроса ```SQL NOW()```: 2023-07-20 15:35:55
Важно понимать, что, если формат даты в каких-то из ячеек неправильный, MySQL все-равно установит в колонке тип данных DATE, но даты в неправильном формате будут искажены. Например, вместо даты 19.05.2007, появится дата 1905-20-07. Поэтому в данном случае можно убедиться, что все даты в правильно формате, если запустить следующий код, который посчитает все значения дат и их количество.

```SQL
SELECT date_creation AS `Значения`, COUNT(date_creation) AS `Количество`
FROM curricula_vitae WHERE date_creation IS NOT NULL
GROUP BY date_creation;
```
В пункте 3.4.2 уже шла речь о том, что если перед загрузкой данных в БД, CSV файл открывается в MS Excel для анализа, важно проследить в каком формате будут сохранены имеющиеся там даты. В случае, если этого сделано не было, даты надо будет вернуть в правильный формат уже в самой БД и помогут в этом регулярные выражения. Данные запросы предполагают создание дополнительного столбца, куда и будут сохраняться даты в правильном формате. Это гарантирует сохранность первоначальных данных. Ненужный столбец можно будет потом удалить, убедившись, что в созданный столбец все даты сохранились так как нужно. 

```SQL
-- создаем нужный столбец после искомого столбца сразу с правильным типом данных DATE
ALTER TABLE vacancies ADD COLUMN date_change_inner_info_2 DATE AFTER date_change_inner_info;

-- С помощью функции CONVERT() переводим все даты из одной колонки в другую сразу конвертируя в тип данных DATE.
-- Помним, что даты в некорректном формате конвертируются не правильно. Пока это не критично.
UPDATE vacancies 
SET date_change_inner_info_2 = (SELECT CONVERT(date_change_inner_info, DATE));
 
-- Исправляем даты, которые конвертировались с ошибкой из-за неправильного начального формата.
-- Используем регулярное выражение для поиска дат с неправильным форматом. Каждое нижнее подчеркивание означает один любой символ.
-- Функция STR_TO_DATE() принимает 2 аргумента: дату в виде строки и формат, задающий где в этой строке действительно значение дня, года и месяца.
-- Сохраняется дата уже правильно в формате, подходящем для столбца DATE в MySQL.
UPDATE vacancies 
SET date_change_inner_info_2 = STR_TO_DATE(date_change_inner_info, '%d.%m.%Y') 
WHERE date_change_inner_info LIKE '__.__.____';

-- Проверяем значения в обоих столбцах. Группируем, чтобы сохратить размер колонок.
SELECT date_change_inner_info, date_change_inner_info_2 
FROM vacancies
GROUP BY date_change_inner_info, date_change_inner_info_2;

-- удаляем столбец, который не нужен
ALTER TABLE vacancies DROP COLUMN date_change_inner_info;
-- меняем название столбца
ALTER TABLE vacancies CHANGE date_change_inner_info_2 date_change_inner_info DATE;
```

Запрос будет еще сложнее, если предстоит исправить сразу несколько неверных форматов дат. В данном примере речь идет не только про дату DATE, но и про время - тип данных DATETIME. Используем оператор CASE. Он позволяет задать сразу несколько условий в одном запросе. 

```SQL
-- исправления в нескольо этапов 
UPDATE vac_2020_21 SET date_time_change_inner_info_2 = 
CASE 
    WHEN date_time_change_inner_info LIKE '__.__.____ __:__' 
		THEN STR_TO_DATE(date_time_change_inner_info, '%d.%m.%Y %H:%i') 
    WHEN date_time_change_inner_info LIKE '__.__.____ _:__' 
		THEN STR_TO_DATE(date_time_change_inner_info, '%d.%m.%Y %k:%i') 
    ELSE CONVERT(date_time_change_inner_info, DATETIME)
END;
```
## 3.7 Дубликаты строк в таблицах.

Один из способов оптимизации работы БД - это удаление дубликатов строк. Могут быть разные причины их появления, начиная от ошибочного введения дубликатов пользователями и до сбоев в работе системы. Поэтому каждая таблица была проверена на наличие полностью одинактовых строк. 
Данный запрос создает таблицу, в которую сохраняет все неповторяющиеся (уникальные) строки из таблицы с дубликатами. Затем искомую таблицу можно удалить, а таблицу, уже созданную и заполненную без дубликатов переименовать.

```SQL
CREATE TABLE `table_tmp` SELECT DISTINCT * FROM `table_name`;
DROP TABLE `table_name`;
RENAME TABLE `table_tmp` TO `table_name`; 
```
Таким образом в таблице workexp, в которую вводились данные об опыте работы соискателей, оказалось 448 дубликатов, которые данный запрос и удалил.

## 3.8 Индекс как средство увеличения производительности в работе с БД.
Самая большая таблица для работы с БД - это таблица vacancies. Ее размер в CSV файле был свыше 20 Гб.
Как можно ускорить работу с такой таблицей? Существует специальный механизм повышения производительности - индексы.
MySQL позволяет построить над каждой таблицей до 32 индексов, а каждый индекс может включать до 16 полей. Когда нужны индексы? Когда часто приходится производить поиск по одному и тому же набору колонок (например, по имени и фамилии, городу и штату и т.д.). Также лучше всего строить индексы по колонкам, которые часто используются в условии WHERE запроса; часто используются во фразе ORDER BY запроса; имеют много различных значений. 
Колонки, где встречается много повторяющихся значений, индексировать не стоит. Отметим, что в MySQL над колонкой, содержащей первичный ключ, индекс строится автоматически.
Следует учитывать, что индексы ускоряют выборку данных из базы, но зато замедляют обновление (поскольку изменять приходится не только сами данные, но и индексы). 
